name: WindowsBuildAndRelease

on:
  workflow_call:
    inputs:
      release_id:
        required: true
        type: string
      package_version:
        required: true
        type: string
      release_upload_url:
        required: true
        type: string
    outputs:
      windows_x86_64_sig:
        description: "Signature for Windows x86_64 build"
        value: ${{ jobs.windowsBuilding.outputs.windows_x86_64_sig }}
      windows_x86_64_name:
        description: "Name for Windows x86_64 build"
        value: ${{ jobs.windowsBuilding.outputs.windows_x86_64_name }}
  workflow_dispatch:


jobs:
  windowsBuilding:
    if: github.event.repository.fork == false
    name: BuildWindows
    permissions:
      contents: write
      id-token: write
      security-events: write
      attestations: write
    outputs:
      windows_x86_64_sig: ${{ steps.extract-signatures.outputs.windows_x86_64_sig }}
      windows_x86_64_name: ${{ steps.extract-signatures.outputs.windows_x86_64_name }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: x86_64-pc-windows-msvc
            arch: x64
            platform: windows/x86_64

    runs-on: windows-latest
    steps:
      - name: üîÑ Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: üõ†Ô∏è Setup/ Node 20
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: üõ†Ô∏è Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: üõ†Ô∏è Install dependencies
        run: bun install

      - name: üåç Export GitHub Actions cache environment variables windows
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
        with:
          script: |
            core.exportVariable('ACTIONS_CACHE_URL', process.env.ACTIONS_CACHE_URL || '');
            core.exportVariable('ACTIONS_RUNTIME_TOKEN', process.env.ACTIONS_RUNTIME_TOKEN || '');

      - name: üîß Install system dependencies
        run: |
          echo "VCPKG_ROOT=$env:VCPKG_INSTALLATION_ROOT" | Out-File -FilePath $env:GITHUB_ENV -Append
          vcpkg install openssl:x64-windows-static-md
          choco install wget -y
        env:
          VCPKG_BINARY_SOURCES: "clear;x-gha,readwrite"

      - name: ü¶Ä Install rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: ‚úèÔ∏è Create env file
        run: |
          echo "VITE_PORT=5173" >> .env
          echo "TAURI_PLATFORM=${{ matrix.platform }}" >> .env
          echo "VITE_API_URI=https://api.codefend.com/index.php" >> .env
          echo "VITE_NODE_ENV=production" >> .env
          echo "VITE_STRIPE_KEY_LIVE=${{ secrets.STRIPE_KEY }}" >> .env
          echo "VITE_STRIPE_KEY_TEST=${{ secrets.STRIPE_KEY_TEST }}" >> .env
          echo "VITE_GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}" >> .env
          echo "VITE_ENABLE_GOOGLE_AUTH=true" >> .env
          echo "VITE_DEBUG=false" >> .env
          echo "VITE_APP_ENV=production" >> .env

      - name: üî® Run build client
        run: bun run build

      - name: üì• Cached install tauri-cli
        uses: taiki-e/cache-cargo-install-action@caa6f48d18d42462f9c30df89e2b4f71a42b7c2c # v2.0.1
        with:
          tool: tauri-cli@2.1.0
          locked: true

      - name: üîê Setup Windows SDK for SignTool
        if: secrets.SSLCOM_USE_ESIGNER != 'true'
        run: |
          # El SignTool ya viene con Windows SDK en GitHub Actions
          # Solo necesitamos verificar que est√© disponible
          $signtoolPath = "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\signtool.exe"
          if (Test-Path $signtoolPath) {
            Write-Host "‚úÖ SignTool encontrado en: $signtoolPath"
          } else {
            Write-Host "‚ö†Ô∏è Buscando SignTool..."
            Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits" -Filter "signtool.exe" -Recurse
          }

      - name: üî® Build using tauri action (publish artifacts on release)
        uses: tauri-apps/tauri-action@v0.5.20 # v0.5.17 - UPDATE to v0.5.20
        env:
          RUSTFLAGS: "-C target-feature=+crt-static"
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
          TAURI_BUNDLE_IDENTIFIER: "com.codefend.app"
          TAURI_BUNDLE_VERSION: ${{ inputs.package_version }}
        with:
          releaseId: ${{ inputs.release_id }}
          args: '--verbose'

      - name: üì¶ Prepare files for signing
        shell: pwsh
        run: |
          # Crear directorio para archivos sin firmar
          New-Item -ItemType Directory -Force -Path "$env:GITHUB_WORKSPACE\to-sign"
          
          # Buscar archivos generados por Tauri
          $msiFiles = Get-ChildItem -Path ".\src-tauri\target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue
          $nsisFiles = Get-ChildItem -Path ".\src-tauri\target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue
          
          # Copiar archivos a firmar
          if ($msiFiles) {
            foreach ($file in $msiFiles) {
              Write-Host "üìã Preparando MSI: $($file.Name)"
              Copy-Item -Path $file.FullName -Destination "$env:GITHUB_WORKSPACE\to-sign\"
            }
          }
          
          if ($nsisFiles) {
            foreach ($file in $nsisFiles) {
              Write-Host "üìã Preparando EXE: $($file.Name)"
              Copy-Item -Path $file.FullName -Destination "$env:GITHUB_WORKSPACE\to-sign\"
            }
          }
          
          # Listar archivos a firmar
          Write-Host "üìù Archivos listos para firmar:"
          Get-ChildItem -Path "$env:GITHUB_WORKSPACE\to-sign" | ForEach-Object { Write-Host "  - $($_.Name)" }

      - name: üîê Sign MSI files with SSL.com eSigner
        uses: sslcom/actions-codesigner@develop
        with:
          command: sign
          username: ${{ secrets.SSLCOM_USERNAME }}
          password: ${{ secrets.SSLCOM_PASSWORD }}
          credential_id: ${{ secrets.SSLCOM_CREDENTIAL_ID }}
          totp_secret: ${{ secrets.SSLCOM_TOTP_SECRET }}
          file_path: ${{ github.workspace }}/to-sign/*.msi
          output_path: ${{ github.workspace }}/signed
          override: true
          malware_block: false

      - name: üîê Sign EXE files with SSL.com eSigner
        uses: sslcom/actions-codesigner@develop
        with:
          command: sign
          username: ${{ secrets.SSLCOM_USERNAME }}
          password: ${{ secrets.SSLCOM_PASSWORD }}
          credential_id: ${{ secrets.SSLCOM_CREDENTIAL_ID }}
          totp_secret: ${{ secrets.SSLCOM_TOTP_SECRET }}
          file_path: ${{ github.workspace }}/to-sign/*.exe
          output_path: ${{ github.workspace }}/signed
          override: true
          malware_block: false

      - name: ‚úÖ Verify signatures
        shell: pwsh
        run: |
          $signedFiles = Get-ChildItem -Path "$env:GITHUB_WORKSPACE\signed" -Include "*.exe", "*.msi" -Recurse
          
          Write-Host "üîç Verificando firmas de archivos..."
          foreach ($file in $signedFiles) {
            Write-Host "`nüìÑ Verificando: $($file.Name)"
            
            # Obtener informaci√≥n del certificado
            $cert = Get-AuthenticodeSignature -FilePath $file.FullName
            
            if ($cert.Status -eq "Valid") {
              Write-Host "‚úÖ Firma v√°lida"
              Write-Host "   Firmado por: $($cert.SignerCertificate.Subject)"
              Write-Host "   Timestamp: $($cert.TimeStamperCertificate.Subject)"
            } else {
              Write-Host "‚ùå Error en la firma: $($cert.Status)"
              exit 1
            }
          }

      - name: üìÇ Replace unsigned files with signed ones
        shell: pwsh
        run: |
          # Copiar archivos firmados de vuelta a las ubicaciones originales
          $signedFiles = Get-ChildItem -Path "$env:GITHUB_WORKSPACE\signed" -Include "*.exe", "*.msi" -Recurse
          
          foreach ($file in $signedFiles) {
            if ($file.Extension -eq ".msi") {
              $destination = ".\src-tauri\target\release\bundle\msi\"
            } elseif ($file.Extension -eq ".exe") {
              $destination = ".\src-tauri\target\release\bundle\nsis\"
            }
            
            Write-Host "üì• Reemplazando: $($file.Name) en $destination"
            Copy-Item -Path $file.FullName -Destination $destination -Force
          }

      - name: üì§ Upload signed artifacts to release
        if: inputs.release_id != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_TAG: codefend-v${{ inputs.package_version }}
        shell: pwsh
        run: |
          # Subir archivos firmados al release
          $signedFiles = Get-ChildItem -Path "$env:GITHUB_WORKSPACE\signed" -Include "*.exe", "*.msi" -Recurse
          
          foreach ($file in $signedFiles) {
            Write-Host "üì§ Subiendo a release: $($file.Name)"
            gh release upload $env:RELEASE_TAG $file.FullName --clobber
          }

      - name: üì§ Upload signed artifacts to workflow
        uses: actions/upload-artifact@v4
        with:
          name: signed-windows-binaries
          path: |
            ${{ github.workspace }}/signed/*.exe
            ${{ github.workspace }}/signed/*.msi
          retention-days: 7

      - name: üìù Extract signatures for outputs
        id: extract-signatures
        shell: pwsh
        run: |
          # Generar hash SHA256 de los archivos firmados
          $msiFile = Get-ChildItem -Path "$env:GITHUB_WORKSPACE\signed" -Filter "*.msi" | Select-Object -First 1
          
          if ($msiFile) {
            $hash = (Get-FileHash -Path $msiFile.FullName -Algorithm SHA256).Hash
            echo "windows_x86_64_sig=$hash" >> $env:GITHUB_OUTPUT
            echo "windows_x86_64_name=$($msiFile.Name)" >> $env:GITHUB_OUTPUT
            
            Write-Host "üìä Signature hash: $hash"
            Write-Host "üì¶ Package name: $($msiFile.Name)"
          }

      - name: üßπ Cleanup temporary files
        if: always()
        shell: pwsh
        run: |
          # Limpiar directorios temporales
          @("to-sign", "signed") | ForEach-Object {
            if (Test-Path "$env:GITHUB_WORKSPACE\$_") {
              Remove-Item -Path "$env:GITHUB_WORKSPACE\$_" -Recurse -Force
              Write-Host "üóëÔ∏è Limpiado: $_"
            }
          }
      # - name: üîê Sign Windows Executables with SSL.com
      #   run: |
      #     # Encontrar los archivos generados por Tauri
      #     $msiFiles = Get-ChildItem -Path ".\src-tauri\target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue
      #     $nsiFiles = Get-ChildItem -Path ".\src-tauri\target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue
      #     $exeFile = Get-Item ".\src-tauri\target\release\*.exe" -ErrorAction SilentlyContinue | Where-Object { $_.Name -like "*codefend*" }
          
      #     Write-Host "üì¶ Archivos encontrados para firmar:"
      #     if ($msiFiles) { Write-Host "  MSI: $($msiFiles.FullName)" }
      #     if ($nsiFiles) { Write-Host "  NSIS: $($nsiFiles.FullName)" }
      #     if ($exeFile) { Write-Host "  EXE: $($exeFile.FullName)" }
          
      #     # Funci√≥n para firmar con eSigner
      #     function Sign-WithESigner {
      #       param($FilePath)
            
      #       java -jar .\codesigntool\CodeSignTool.jar sign `
      #         -credential_id="${{ secrets.SSLCOM_CREDENTIAL_ID }}" `
      #         -username="${{ secrets.SSLCOM_USERNAME }}" `
      #         -password="${{ secrets.SSLCOM_PASSWORD }}" `
      #         -totp_secret="${{ secrets.SSLCOM_TOTP_SECRET }}" `
      #         -input_file_path="$FilePath" `
      #         -override=true
      #     }
          
      #     # Funci√≥n para firmar con SignTool
      #     function Sign-WithSignTool {
      #       param($FilePath)
            
      #       $signtool = "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\signtool.exe"
            
      #       # Si tienes un PFX
      #       if (Test-Path ".\certs\codefend.pfx") {
      #         & $signtool sign /f ".\certs\codefend.pfx" `
      #           /p "${{ secrets.SSLCOM_PASSWORD }}" `
      #           /tr "http://ts.ssl.com" `
      #           /td sha256 `
      #           /fd sha256 `
      #           /v "$FilePath"
      #       }
      #       # Si tienes certificado en el store de Windows
      #       else {
      #         & $signtool sign /n "Codefend, LLC" `
      #           /tr "http://ts.ssl.com" `
      #           /td sha256 `
      #           /fd sha256 `
      #           /v "$FilePath"
      #       }
      #     }
          
      #     # Decidir qu√© m√©todo usar
      #     $useESigner = "${{ secrets.SSLCOM_USE_ESIGNER }}" -eq "true"
          
      #     # Firmar cada archivo
      #     foreach ($file in @($msiFiles, $nsiFiles, $exeFile)) {
      #       if ($file -and (Test-Path $file.FullName)) {
      #         Write-Host "‚úçÔ∏è Firmando: $($file.Name)"
              
      #         if ($useESigner) {
      #           Sign-WithESigner -FilePath $file.FullName
      #         } else {
      #           Sign-WithSignTool -FilePath $file.FullName
      #         }
              
      #         # Verificar firma
      #         $signtool = "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\signtool.exe"
      #         & $signtool verify /pa /v $file.FullName
      #       }
      #     }