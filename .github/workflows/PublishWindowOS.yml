name: WindowsBuildAndRelease

on:
  workflow_call:
    inputs:
      release_id:
        required: true
        type: string
      package_version:
        required: true
        type: string
      release_upload_url:
        required: true
        type: string
    outputs:
      windows_x86_64_sig:
        description: "Signature for Windows x86_64 build"
        value: ${{ jobs.windowsBuilding.outputs.windows_x86_64_sig }}
      windows_x86_64_name:
        description: "Name for Windows x86_64 build"
        value: ${{ jobs.windowsBuilding.outputs.windows_x86_64_name }}
  workflow_dispatch:


jobs:
  windowsBuilding:
    if: github.event.repository.fork == false
    name: BuildWindows
    permissions:
      contents: write
      id-token: write
      security-events: write
      attestations: write
    env:
      USE_ESIGNER: ${{ secrets.SSLCOM_USE_ESIGNER }}
    outputs:
      windows_x86_64_sig: ${{ steps.extract-signatures.outputs.windows_x86_64_sig }}
      windows_x86_64_name: ${{ steps.extract-signatures.outputs.windows_x86_64_name }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: x86_64-pc-windows-msvc
            arch: x64
            platform: windows/x86_64

    runs-on: windows-latest
    steps:
      - name: üîÑ Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: üõ†Ô∏è Setup/ Node 20
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: üõ†Ô∏è Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: üõ†Ô∏è Install dependencies
        run: bun install

      - name: üåç Export GitHub Actions cache environment variables windows
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
        with:
          script: |
            core.exportVariable('ACTIONS_CACHE_URL', process.env.ACTIONS_CACHE_URL || '');
            core.exportVariable('ACTIONS_RUNTIME_TOKEN', process.env.ACTIONS_RUNTIME_TOKEN || '');

      - name: üîß Install system dependencies
        run: |
          echo "VCPKG_ROOT=$env:VCPKG_INSTALLATION_ROOT" | Out-File -FilePath $env:GITHUB_ENV -Append
          choco install wget -y
        env:
          VCPKG_BINARY_SOURCES: "clear;x-gha,readwrite"

      - name: ü¶Ä Install rust stable
        uses: dtolnay/rust-toolchain@stable

      - name: ‚úèÔ∏è Create env file
        run: |
          echo "VITE_PORT=5173" >> .env
          echo "TAURI_PLATFORM=${{ matrix.platform }}" >> .env
          echo "VITE_API_URI=https://api.codefend.com/index.php" >> .env
          echo "VITE_NODE_ENV=production" >> .env
          echo "VITE_STRIPE_KEY_LIVE=${{ secrets.STRIPE_KEY }}" >> .env
          echo "VITE_STRIPE_KEY_TEST=${{ secrets.STRIPE_KEY_TEST }}" >> .env
          echo "VITE_GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}" >> .env
          echo "VITE_ENABLE_GOOGLE_AUTH=true" >> .env
          echo "VITE_DEBUG=false" >> .env
          echo "VITE_APP_ENV=production" >> .env

      # - name: üî® Run build client
      #   run: bun run build

      - name: üî® Build using tauri action (publish artifacts on release)
        uses: tauri-apps/tauri-action@v0.5.20 # v0.5.17 - UPDATE to v0.5.20
        env:
          RUSTFLAGS: "-C target-feature=+crt-static"
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
          TAURI_BUNDLE_IDENTIFIER: "com.codefend.app"
          TAURI_BUNDLE_VERSION: ${{ inputs.package_version }}
        with:
          args: '--verbose'

      - name: ‚òï Setup Java 17 (Temurin)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'

      - name: üì• Download and Setup CodeSignTool
        id: setup-codesigntool
        shell: pwsh
        run: |
          # Descargar CodeSignTool para Windows
          Write-Host "üì• Descargando CodeSignTool..."
          Invoke-WebRequest -Uri "https://www.ssl.com/download/codesigntool-for-windows/" -OutFile "CodeSignTool.zip"
          
          # Extraer
          Write-Host "üì¶ Extrayendo CodeSignTool..."
          Expand-Archive -Path "CodeSignTool.zip" -DestinationPath "$env:GITHUB_WORKSPACE\codesigntool" -Force
          
          # Verificar contenido
          Write-Host "üìÇ Contenido de CodeSignTool:"
          Get-ChildItem -Path "$env:GITHUB_WORKSPACE\codesigntool" -Recurse -Name | Head -20
          
          # Verificar si hay JDK incluido
          $jdkPath = Get-ChildItem -Path "$env:GITHUB_WORKSPACE\codesigntool" -Filter "*jdk*" -Recurse -Directory | Select-Object -First 1
          if ($jdkPath) {
            Write-Host "‚úÖ JDK encontrado en: $($jdkPath.FullName)"
          } else {
            Write-Host "‚ö†Ô∏è No se encontr√≥ JDK incluido"
          }
          
          # Buscar el archivo .bat - puede estar en diferentes ubicaciones
          $possiblePaths = @(
            "$env:GITHUB_WORKSPACE\codesigntool\CodeSignTool.bat",
            "$env:GITHUB_WORKSPACE\codesigntool\CodeSignTool-v1.3.0\CodeSignTool.bat",
            "$env:GITHUB_WORKSPACE\codesigntool\CodeSignTool-v1.2.7\CodeSignTool.bat"
          )
          
          $batFile = $null
          foreach ($path in $possiblePaths) {
            if (Test-Path $path) {
              $batFile = $path
              break
            }
          }
          
          # Si no se encuentra en las rutas conocidas, buscar recursivamente
          if (-not $batFile) {
            $foundBat = Get-ChildItem -Path "$env:GITHUB_WORKSPACE\codesigntool" -Filter "CodeSignTool*.bat" -Recurse | Select-Object -First 1
            if ($foundBat) {
              $batFile = $foundBat.FullName
            }
          }
          

          Write-Host "‚úÖ CodeSignTool.bat encontrado en: $batFile"
          # Guardar como output del step
          echo "CODESIGNTOOL_BAT=$batFile" >> $env:GITHUB_OUTPUT
            
          # Verificar que el archivo es ejecutable
          Write-Host "üîç Verificando CodeSignTool.bat..."
            
          # Obtener el directorio del bat file para verificar estructura
          $batDir = Split-Path -Parent $batFile
          Write-Host "üìÅ Directorio del bat file: $batDir"
          echo "CODESIGNTOOL_DIR=$batDir" >> $env:GITHUB_OUTPUT
            
          # Listar contenido del directorio
          Write-Host "üìã Archivos en el directorio:"
          Get-ChildItem -Path $batDir -Name
            
          # Verificar si existe el JDK en la misma estructura
          $javaExe = Get-ChildItem -Path $batDir -Filter "java.exe" -Recurse | Select-Object -First 1
          if ($javaExe) {
            Write-Host "‚òï Java encontrado en: $($javaExe.FullName)"
          } else {
            Write-Host "‚ö†Ô∏è Java no encontrado en el directorio del bat"
          }


      - name: üì¶ Prepare files for signing
        shell: pwsh
        run: |
          # Crear directorio para archivos firmados
          New-Item -ItemType Directory -Force -Path "$env:GITHUB_WORKSPACE\signed"
          
          # Buscar archivos generados por Tauri (excluyendo archivos .sig)
          $msiFiles = Get-ChildItem -Path ".\src-tauri\target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*.sig" }
          $nsisFiles = Get-ChildItem -Path ".\src-tauri\target\release\bundle\nsis" -Filter "*setup.exe" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*.sig" }
          
          # Tambi√©n buscar cualquier .exe que no sea .sig
          if (-not $nsisFiles) {
            $nsisFiles = Get-ChildItem -Path ".\src-tauri\target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*.sig" }
          }
          
          Write-Host "üìù Archivos encontrados para firmar:"
          Write-Host "üìÅ Buscando en: $(Resolve-Path '.\src-tauri\target\release\bundle')"
          
          if ($msiFiles) {
            foreach ($file in $msiFiles) {
              # Convertir a ruta relativa desde el directorio de trabajo
              $relativePath = ".\src-tauri\target\release\bundle\msi\$($file.Name)"
              Write-Host "  MSI: $($file.FullName)"
              Write-Host "  MSI (relative): $relativePath"
              # Exportar ruta ABSOLUTA para evitar problemas de cwd
              echo "MSI_FILE=$($file.FullName)" >> $env:GITHUB_ENV
            }
          } else {
            Write-Host "  ‚ö†Ô∏è No se encontraron archivos MSI"
          }
          
          if ($nsisFiles) {
            foreach ($file in $nsisFiles) {
              # Convertir a ruta relativa desde el directorio de trabajo
              $relativePath = ".\src-tauri\target\release\bundle\nsis\$($file.Name)"
              Write-Host "  EXE: $($file.FullName)"
              Write-Host "  EXE (relative): $relativePath"
              # Exportar ruta ABSOLUTA para evitar problemas de cwd
              echo "EXE_FILE=$($file.FullName)" >> $env:GITHUB_ENV
            }
          } else {
            Write-Host "  ‚ö†Ô∏è No se encontraron archivos EXE"
            # Listar todos los archivos en el directorio para debug
            Write-Host "üìã Contenido del directorio nsis:"
            Get-ChildItem -Path ".\src-tauri\target\release\bundle\nsis" -ErrorAction SilentlyContinue | ForEach-Object {
              Write-Host "    $($_.Name)"
            }
          }

      - name: üîç Scan MSI file with CodeSignTool
        if: env.MSI_FILE != ''
        shell: pwsh
        env:
          SSL_USERNAME: ${{ secrets.SSLCOM_USERNAME }}
          SSL_PASSWORD: ${{ secrets.SSLCOM_PASSWORD }}
          CREDENTIAL_ID: ${{ secrets.SSLCOM_CREDENTIAL_ID }}
        run: |
          Write-Host "üîç Escaneando MSI: $env:MSI_FILE"
          
          # Verificar que el archivo existe antes del escaneo
          if (-not (Test-Path "$env:MSI_FILE")) {
            Write-Error "‚ùå Archivo MSI no encontrado: $env:MSI_FILE"
            exit 1
          }
          
          # Comando para escanear - escapar rutas con espacios
          $arguments = @(
            "scan_code",
            "-credential_id", "`"$env:CREDENTIAL_ID`"",
            "-input_file_path", "`"$env:MSI_FILE`"",
            "-username", "`"$env:SSL_USERNAME`"",
            "-password", "`"$env:SSL_PASSWORD`""
          )
          
          # Ejecutar escaneo
          $batPath = "${{ steps.setup-codesigntool.outputs.CODESIGNTOOL_BAT }}"
          $batDir = Split-Path -Parent $batPath
          Push-Location $batDir
          try {
            $scanOutput = & cmd.exe /c "`"CodeSignTool.bat`" $($arguments -join ' ')" 2>&1
          } finally {
            Pop-Location
          }
          Write-Host "Resultado del escaneo: $scanOutput"
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "‚ùå Error en el escaneo del MSI"
            exit 1
          }
          
          # Verificar que el c√≥digo no es malware
          if ($scanOutput -match "code object is not a malware") {
            Write-Host "‚úÖ MSI verificado - no es malware, procediendo con la firma"
          } else {
            Write-Warning "‚ö†Ô∏è Advertencia en escaneo, pero continuando..."
          }

      - name: üîê Sign MSI file with CodeSignTool
        if: env.MSI_FILE != ''
        shell: pwsh
        env:
          SSL_USERNAME: ${{ secrets.SSLCOM_USERNAME }}
          SSL_PASSWORD: ${{ secrets.SSLCOM_PASSWORD }}
          CREDENTIAL_ID: ${{ secrets.SSLCOM_CREDENTIAL_ID }}
          SSL_TOTP_SECRET: ${{ secrets.SSLCOM_TOTP_SECRET }}
        run: |
          Write-Host "üîê Firmando MSI: $env:MSI_FILE"
          
          # Comando para firmar - escapar rutas con espacios
          $arguments = @(
            "sign",
            "-credential_id", "`"$env:CREDENTIAL_ID`"",
            "-input_file_path", "`"$env:MSI_FILE`"",
            "-username", "`"$env:SSL_USERNAME`"",
            "-password", "`"$env:SSL_PASSWORD`"",
            "-output_dir_path", "`"$env:GITHUB_WORKSPACE\signed`"",
            "-totp_secret", "`"$env:SSL_TOTP_SECRET`""
          )
          
          # Ejecutar firma
          $batPath = "${{ steps.setup-codesigntool.outputs.CODESIGNTOOL_BAT }}"
          $batDir = Split-Path -Parent $batPath
          Push-Location $batDir
          try {
            & cmd.exe /c "`"CodeSignTool.bat`" $($arguments -join ' ')"
          } finally {
            Pop-Location
          }
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "‚ùå Error al firmar MSI"
            exit 1
          }
          
          Write-Host "‚úÖ MSI firmado exitosamente"

      - name: üîç Scan EXE file with CodeSignTool
        if: env.EXE_FILE != ''
        shell: pwsh
        env:
          SSL_USERNAME: ${{ secrets.SSLCOM_USERNAME }}
          SSL_PASSWORD: ${{ secrets.SSLCOM_PASSWORD }}
          CREDENTIAL_ID: ${{ secrets.SSLCOM_CREDENTIAL_ID }}
        run: |
          Write-Host "üîç Escaneando EXE: $env:EXE_FILE"
          
          # Verificar que el archivo existe antes del escaneo
          if (-not (Test-Path "$env:EXE_FILE")) {
            Write-Error "‚ùå Archivo EXE no encontrado: $env:EXE_FILE"
            exit 1
          }
          
          # Comando para escanear - escapar rutas con espacios
          $arguments = @(
            "scan_code",
            "-credential_id", "`"$env:CREDENTIAL_ID`"",
            "-input_file_path", "`"$env:EXE_FILE`"",
            "-username", "`"$env:SSL_USERNAME`"",
            "-password", "`"$env:SSL_PASSWORD`""
          )
          
          # Ejecutar escaneo
          $batPath = "${{ steps.setup-codesigntool.outputs.CODESIGNTOOL_BAT }}"
          $batDir = Split-Path -Parent $batPath
          Push-Location $batDir
          try {
            $scanOutput = & cmd.exe /c "`"CodeSignTool.bat`" $($arguments -join ' ')" 2>&1
          } finally {
            Pop-Location
          }
          Write-Host "Resultado del escaneo: $scanOutput"
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "‚ùå Error en el escaneo del EXE"
            exit 1
          }
          
          # Verificar que el c√≥digo no es malware
          if ($scanOutput -match "code object is not a malware") {
            Write-Host "‚úÖ EXE verificado - no es malware, procediendo con la firma"
          } else {
            Write-Warning "‚ö†Ô∏è Advertencia en escaneo, pero continuando..."
          }

      - name: üîê Sign EXE file with CodeSignTool
        if: env.EXE_FILE != ''
        shell: pwsh
        env:
          SSL_USERNAME: ${{ secrets.SSLCOM_USERNAME }}
          SSL_PASSWORD: ${{ secrets.SSLCOM_PASSWORD }}
          CREDENTIAL_ID: ${{ secrets.SSLCOM_CREDENTIAL_ID }}
          SSL_TOTP_SECRET: ${{ secrets.SSLCOM_TOTP_SECRET }}
        run: |
          Write-Host "üîê Firmando EXE: $env:EXE_FILE"
          
          # Comando para firmar - escapar rutas con espacios
          $arguments = @(
            "sign",
            "-credential_id", "`"$env:CREDENTIAL_ID`"",
            "-input_file_path", "`"$env:EXE_FILE`"",
            "-username", "`"$env:SSL_USERNAME`"",
            "-password", "`"$env:SSL_PASSWORD`"",
            "-output_dir_path", "`"$env:GITHUB_WORKSPACE\signed`"",
            "-totp_secret", "`"$env:SSL_TOTP_SECRET`""
          )
          
          # Ejecutar firma
          $batPath = "${{ steps.setup-codesigntool.outputs.CODESIGNTOOL_BAT }}"
          $batDir = Split-Path -Parent $batPath
          Push-Location $batDir
          try {
            & cmd.exe /c "`"CodeSignTool.bat`" $($arguments -join ' ')"
          } finally {
            Pop-Location
          }
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "‚ùå Error al firmar EXE"
            exit 1
          }
          
          Write-Host "‚úÖ EXE firmado exitosamente"

      - name: ‚úÖ Verify signatures
        shell: pwsh
        run: |
          Write-Host "üîç Verificando firmas digitales de los binarios finales..."
          
          # Buscar primero en carpeta /signed (excluyendo .sig)
          $finalFiles = @()
          $signedFiles = Get-ChildItem -Path "$env:GITHUB_WORKSPACE\signed" -Include "*.msi", "*.exe" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*.sig" }
          if ($signedFiles -and $signedFiles.Count -gt 0) {
            Write-Host "üìÅ Usando archivos firmados desde: $env:GITHUB_WORKSPACE\signed"
            $finalFiles = $signedFiles
          } else {
            Write-Host "‚ÑπÔ∏è No hay archivos en /signed, verificando en ubicaciones originales"
            $finalFiles += Get-ChildItem -Path ".\src-tauri\target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*.sig" }
            $finalFiles += Get-ChildItem -Path ".\src-tauri\target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*.sig" }
          }
          
          if ($finalFiles.Count -eq 0) {
            Write-Error "‚ùå No se encontraron archivos finales para verificar"
            exit 1
          }
          
          $allValid = $true
          
          Write-Host "üìã Archivos a verificar:"
          foreach ($file in $finalFiles) {
            Write-Host "  - $($file.FullName)"
          }
          
          Write-Host "`nüîç Iniciando verificaci√≥n de firmas..."
          foreach ($file in $finalFiles) {
            Write-Host "`nüìÑ Verificando: $($file.Name) ($($file.Length) bytes)"
            
            try {
              # Obtener informaci√≥n del certificado usando Get-AuthenticodeSignature
              $cert = Get-AuthenticodeSignature -FilePath $file.FullName
              
              Write-Host "   Estado de firma: $($cert.Status)"
              
              if ($cert.Status -eq "Valid") {
                Write-Host "‚úÖ Firma V√ÅLIDA"
                Write-Host "   üìã Detalles del certificado:"
                Write-Host "      Firmado por: $($cert.SignerCertificate.Subject)"
                Write-Host "      Emisor: $($cert.SignerCertificate.Issuer)"
                Write-Host "      V√°lido desde: $($cert.SignerCertificate.NotBefore)"
                Write-Host "      V√°lido hasta: $($cert.SignerCertificate.NotAfter)"
                
                if ($cert.TimeStamperCertificate) {
                  Write-Host "   ‚è∞ Timestamp v√°lido: $($cert.TimeStamperCertificate.Subject)"
                }
                
                # Verificar que es SSL.com
                if ($cert.SignerCertificate.Subject -like "*SSL Corp*" -or $cert.SignerCertificate.Issuer -like "*SSL.com*") {
                  Write-Host "   üè¢ Certificado de SSL.com confirmado"
                } else {
                  Write-Warning "   ‚ö†Ô∏è Certificado no parece ser de SSL.com"
                }
                
              } else {
                Write-Host "‚ùå Firma INV√ÅLIDA o faltante"
                Write-Host "   Error: $($cert.Status)"
                if ($cert.StatusMessage) {
                  Write-Host "   Mensaje: $($cert.StatusMessage)"
                }
                $allValid = $false
              }
              
            } catch {
              Write-Error "‚ùå Error al verificar firma de $($file.Name): $($_.Exception.Message)"
              $allValid = $false
            }
          }
          
          Write-Host "`nüìä Resumen de verificaci√≥n:"
          if ($allValid) {
            Write-Host "‚úÖ TODOS los archivos tienen firmas v√°lidas"
            Write-Host "üéâ Los binarios firmados est√°n listos para distribuci√≥n"
          } else {
            Write-Warning "‚ö†Ô∏è ALGUNOS archivos no tienen firmas v√°lidas"
            Write-Host "üí° Los archivos se distribuir√°n pero pueden mostrar advertencias de seguridad"
            # No fallar el build, solo advertir
          }

      
      - name: üìÇ Move signed files to correct location
        shell: pwsh
        run: |
          Write-Host "üìÇ Gestionando archivos firmados..."
          
          # Verificar archivos en carpeta /signed (excluyendo archivos .sig)
          $signedFiles = Get-ChildItem -Path "$env:GITHUB_WORKSPACE\signed" -Include "*.exe", "*.msi" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*.sig" }
          
          if ($signedFiles.Count -gt 0) {
            Write-Host "‚úÖ Encontrados $($signedFiles.Count) archivos firmados en carpeta /signed"
            
            foreach ($file in $signedFiles) {
              if ($file.Extension -eq ".msi") {
                $destination = ".\src-tauri\target\release\bundle\msi\"
                Write-Host "üì• Reemplazando MSI original con versi√≥n firmada: $($file.Name)"
              } elseif ($file.Extension -eq ".exe") {
                $destination = ".\src-tauri\target\release\bundle\nsis\"
                Write-Host "üì• Reemplazando EXE original con versi√≥n firmada: $($file.Name)"
              }
              
              # Crear directorio de destino si no existe
              if (-not (Test-Path $destination)) {
                New-Item -ItemType Directory -Path $destination -Force
              }
              
              # Mover archivo firmado reemplazando el original
              Move-Item -Path $file.FullName -Destination $destination -Force
              Write-Host "‚úÖ Archivo firmado movido a: $destination$($file.Name)"
            }
          } else {
            Write-Host "‚ÑπÔ∏è No se encontraron archivos en /signed, verificando si fueron firmados in-place"
            
            # Verificar si los archivos originales est√°n ahora firmados
            $originalFiles = @()
            if ($env:MSI_FILE -and (Test-Path $env:MSI_FILE)) { 
              $originalFiles += Get-Item $env:MSI_FILE 
            }
            if ($env:EXE_FILE -and (Test-Path $env:EXE_FILE)) { 
              $originalFiles += Get-Item $env:EXE_FILE 
            }
            
            foreach ($file in $originalFiles) {
              $signature = Get-AuthenticodeSignature -FilePath $file.FullName
              if ($signature.Status -eq "Valid") {
                Write-Host "‚úÖ $($file.Name) est√° firmado correctamente (in-place)"
              } else {
                Write-Warning "‚ö†Ô∏è $($file.Name) no parece estar firmado correctamente"
              }
            }
          }

      - name: üîè Generate Tauri updater .sig for final signed binaries
        shell: pwsh
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        run: |
          Write-Host "üîè Generando .sig del updater para binarios FINALES (post-codesigning)..."
          $artifacts = @()
          $artifacts += Get-ChildItem -Path ".\src-tauri\target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue
          $artifacts += Get-ChildItem -Path ".\src-tauri\target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue

          if ($artifacts.Count -eq 0) {
            Write-Error "‚ùå No se encontraron artefactos finales para firmar con Tauri signer"
            exit 1
          }

          foreach ($artifact in $artifacts) {
            Write-Host "üñäÔ∏è Generando firma Tauri para: $($artifact.Name)"

            $filePath = "`"$($artifact.FullName)`""
            
            $bunArgs = @(
              "x", "--yes", "@tauri-apps/cli@latest", "signer", "sign",
              "--private-key", "$env:TAURI_SIGNING_PRIVATE_KEY",
              "--password", "$env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD",
              $filePath
            )
            
            $null = (& bun @bunArgs)
            
            if ($LASTEXITCODE -ne 0) {
              Write-Error "‚ùå Error generando .sig para $($artifact.Name)"
              exit 1
            }

            $expectedSig = "$($artifact.FullName).sig"
            if (-not (Test-Path $expectedSig)) {
              Write-Error "‚ùå No se gener√≥ el archivo .sig esperado: $expectedSig"
              exit 1
            }
            Write-Host "‚úÖ .sig generado: $expectedSig"
          }

      - name: üì§ Upload signed artifacts to release
        if: inputs.release_id != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: pwsh
        run: |
          # Buscar archivos firmados en sus ubicaciones finales (excluyendo .sig)
          $tag = "codefend-v${{ inputs.package_version }}"
          $repo = "$env:GITHUB_REPOSITORY"
          Write-Host "üè∑Ô∏è Publicando en release/tag: $tag en repo: $repo"
          $artifacts = @()
          $artifacts += Get-ChildItem -Path ".\src-tauri\target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*.sig" }
          $artifacts += Get-ChildItem -Path ".\src-tauri\target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*.sig" }
          
          foreach ($artifact in $artifacts) {
            if (Test-Path $artifact.FullName) {
              Write-Host "üì§ Subiendo a release: $($artifact.Name)"
              gh release upload $tag "$(($artifact.FullName))" --repo $repo --clobber
              $sigPath = "$($artifact.FullName).sig"
              if (Test-Path $sigPath) {
                Write-Host "üì§ Subiendo .sig a release: $(Split-Path $sigPath -Leaf)"
                gh release upload $tag "$sigPath" --repo $repo --clobber
              } else {
                Write-Warning "‚ö†Ô∏è No se encontr√≥ .sig para $($artifact.Name) en $sigPath"
              }
            }
          }

      - name: üì§ Upload signed artifacts to workflow
        uses: actions/upload-artifact@v4
        with:
          name: signed-windows-binaries
          path: |
            src-tauri/target/release/bundle/msi/*.msi
            src-tauri/target/release/bundle/nsis/*.exe
            src-tauri/target/release/bundle/msi/*.sig
            src-tauri/target/release/bundle/nsis/*.sig
          retention-days: 7

      # ============= EXTRAER SIGNATURES PARA OUTPUTS =============
      
      - name: üìù Extract signatures for outputs
        id: extract-signatures
        shell: pwsh
        run: |
          # Seleccionar artefacto principal (MSI preferido; si no, EXE)
          $msiFile = Get-ChildItem -Path ".\src-tauri\target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*.sig" } | Select-Object -First 1
          $exeFile = Get-ChildItem -Path ".\src-tauri\target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*.sig" } | Select-Object -First 1
          $artifact = $msiFile
          if (-not $artifact) { $artifact = $exeFile }

          if ($artifact) {
            $sigFile = "$($artifact.FullName).sig"
            if (-not (Test-Path $sigFile)) {
              Write-Error "‚ùå No se encontr√≥ archivo .sig para $($artifact.Name) en $sigFile. Aseg√∫rate de ejecutar el paso de generaci√≥n de .sig."
              exit 1
            }

            $signature = (Get-Content -Raw -Path $sigFile).Trim()

            echo "windows_x86_64_sig=$signature" >> $env:GITHUB_OUTPUT
            echo "windows_x86_64_name=$($artifact.Name)" >> $env:GITHUB_OUTPUT

            Write-Host "üì¶ Package name: $($artifact.Name)"
            Write-Host "üñäÔ∏è Signature (trunc): $($signature.Substring(0, [Math]::Min(16, $signature.Length)))..."
          } else {
            Write-Error "‚ùå No se encontr√≥ artefacto MSI o EXE para extraer firma"
            exit 1
          }

      # ============= LIMPIAR ARCHIVOS TEMPORALES =============
      
      - name: üßπ Cleanup temporary files
        if: always()
        shell: pwsh
        run: |
          # Limpiar directorios temporales
          @("codesigntool", "signed") | ForEach-Object {
            if (Test-Path "$env:GITHUB_WORKSPACE\$_") {
              Remove-Item -Path "$env:GITHUB_WORKSPACE\$_" -Recurse -Force
              Write-Host "üóëÔ∏è Limpiado: $_"
            }
          }
          
          # Limpiar archivo ZIP
          if (Test-Path "CodeSignTool.zip") {
            Remove-Item "CodeSignTool.zip" -Force
          }
