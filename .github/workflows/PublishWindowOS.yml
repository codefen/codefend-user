name: WindowsBuildAndRelease

on:
  workflow_call:
    inputs:
      release_id:
        required: true
        type: string
      package_version:
        required: true
        type: string
      release_upload_url:
        required: true
        type: string
    outputs:
      windows_x86_64_sig:
        description: "Signature for Windows x86_64 build"
        value: ${{ jobs.windowsBuilding.outputs.windows_x86_64_sig }}
      windows_x86_64_name:
        description: "Name for Windows x86_64 build"
        value: ${{ jobs.windowsBuilding.outputs.windows_x86_64_name }}
  workflow_dispatch:


jobs:
  windowsBuilding:
    if: github.event.repository.fork == false
    name: BuildWindows
    permissions:
      contents: write
      id-token: write
      security-events: write
      attestations: write
    env:
      USE_ESIGNER: ${{ secrets.SSLCOM_USE_ESIGNER }}
    outputs:
      windows_x86_64_sig: ${{ steps.extract-signatures.outputs.windows_x86_64_sig }}
      windows_x86_64_name: ${{ steps.extract-signatures.outputs.windows_x86_64_name }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: x86_64-pc-windows-msvc
            arch: x64
            platform: windows/x86_64

    runs-on: windows-latest
    steps:
      - name: üîÑ Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: üõ†Ô∏è Setup/ Node 20
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: üõ†Ô∏è Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: üõ†Ô∏è Install dependencies
        run: bun install

      - name: üåç Export GitHub Actions cache environment variables windows
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
        with:
          script: |
            core.exportVariable('ACTIONS_CACHE_URL', process.env.ACTIONS_CACHE_URL || '');
            core.exportVariable('ACTIONS_RUNTIME_TOKEN', process.env.ACTIONS_RUNTIME_TOKEN || '');

      - name: üîß Install system dependencies
        run: |
          echo "VCPKG_ROOT=$env:VCPKG_INSTALLATION_ROOT" | Out-File -FilePath $env:GITHUB_ENV -Append
          vcpkg install openssl:x64-windows-static-md
          choco install wget -y
        env:
          VCPKG_BINARY_SOURCES: "clear;x-gha,readwrite"

      - name: ü¶Ä Install rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: ‚úèÔ∏è Create env file
        run: |
          echo "VITE_PORT=5173" >> .env
          echo "TAURI_PLATFORM=${{ matrix.platform }}" >> .env
          echo "VITE_API_URI=https://api.codefend.com/index.php" >> .env
          echo "VITE_NODE_ENV=production" >> .env
          echo "VITE_STRIPE_KEY_LIVE=${{ secrets.STRIPE_KEY }}" >> .env
          echo "VITE_STRIPE_KEY_TEST=${{ secrets.STRIPE_KEY_TEST }}" >> .env
          echo "VITE_GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}" >> .env
          echo "VITE_ENABLE_GOOGLE_AUTH=true" >> .env
          echo "VITE_DEBUG=false" >> .env
          echo "VITE_APP_ENV=production" >> .env

      - name: üî® Run build client
        run: bun run build

      - name: üì• Cached install tauri-cli
        uses: taiki-e/cache-cargo-install-action@caa6f48d18d42462f9c30df89e2b4f71a42b7c2c # v2.0.1
        with:
          tool: tauri-cli@2.1.0
          locked: true

      - name: üîê Setup Windows SDK for SignTool
        if: env.USE_ESIGNER != 'true'
        run: |
          # El SignTool ya viene con Windows SDK en GitHub Actions
          # Solo necesitamos verificar que est√© disponible
          $signtoolPath = "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\signtool.exe"
          if (Test-Path $signtoolPath) {
            Write-Host "‚úÖ SignTool encontrado en: $signtoolPath"
          } else {
            Write-Host "‚ö†Ô∏è Buscando SignTool..."
            Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits" -Filter "signtool.exe" -Recurse
          }

      - name: üî® Build using tauri action (publish artifacts on release)
        uses: tauri-apps/tauri-action@v0.5.20 # v0.5.17 - UPDATE to v0.5.20
        env:
          RUSTFLAGS: "-C target-feature=+crt-static"
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
          TAURI_BUNDLE_IDENTIFIER: "com.codefend.app"
          TAURI_BUNDLE_VERSION: ${{ inputs.package_version }}
        with:
          releaseId: ${{ inputs.release_id }}
          args: '--verbose'

      - name: ‚òï Setup Java for CodeSignTool
        if: env.USE_ESIGNER == 'true'
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: üì• Download SSL.com CodeSignTool
        if: env.USE_ESIGNER == 'true'
        shell: pwsh
        run: |
          Write-Host "üì• Descargando CodeSignTool..."
          wget -O CodeSignTool.zip "https://www.ssl.com/download/codesigntool-for-windows/"
          
          Write-Host "üì¶ Extrayendo CodeSignTool..."
          Expand-Archive -Path "CodeSignTool.zip" -DestinationPath "codesigntool" -Force
          
          # Buscar el JAR en el directorio extra√≠do
          $jarFile = Get-ChildItem -Path "codesigntool" -Filter "CodeSignTool*.jar" -Recurse | Select-Object -First 1
          
          if ($jarFile) {
            Write-Host "‚úÖ CodeSignTool JAR encontrado: $($jarFile.FullName)"
            echo "CODESIGNTOOL_JAR=$($jarFile.FullName)" >> $env:GITHUB_ENV
          } else {
            Write-Error "‚ùå No se encontr√≥ el archivo JAR de CodeSignTool"
            exit 1
          }

      - name: üì¶ Prepare files for signing
        shell: pwsh
        run: |
          # Crear directorio para archivos firmados
          New-Item -ItemType Directory -Force -Path "$env:GITHUB_WORKSPACE\signed"
          
          # Buscar archivos generados por Tauri
          $msiFiles = Get-ChildItem -Path ".\src-tauri\target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue
          $nsisFiles = Get-ChildItem -Path ".\src-tauri\target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue
          
          Write-Host "üìù Archivos encontrados para firmar:"
          if ($msiFiles) {
            foreach ($file in $msiFiles) {
              Write-Host "  MSI: $($file.FullName)"
              echo "MSI_FILE=$($file.FullName)" >> $env:GITHUB_ENV
            }
          }
          
          if ($nsisFiles) {
            foreach ($file in $nsisFiles) {
              Write-Host "  EXE: $($file.FullName)"
              echo "EXE_FILE=$($file.FullName)" >> $env:GITHUB_ENV
            }
          }

      - name: üîê Sign MSI file with CodeSignTool
        if: env.MSI_FILE != ''
        shell: pwsh
        env:
          ES_USERNAME: ${{ secrets.SSLCOM_USERNAME }}
          ES_PASSWORD: ${{ secrets.SSLCOM_PASSWORD }}
          CREDENTIAL_ID: ${{ secrets.SSLCOM_CREDENTIAL_ID }}
          ES_TOTP_SECRET: ${{ secrets.SSLCOM_TOTP_SECRET }}
        run: |
          Write-Host "üîê Firmando MSI: $env:MSI_FILE"
          
          # Comando para firmar
          $arguments = @(
            "-jar", "$env:CODESIGNTOOL_JAR",
            "sign",
            "-username", "$env:ES_USERNAME",
            "-password", "$env:ES_PASSWORD",
            "-totp_secret", "$env:ES_TOTP_SECRET",
            "-input_file_path", "$env:MSI_FILE",
            "-output_dir_path", "$env:GITHUB_WORKSPACE\signed"
          )
          
          # Agregar credential_id si est√° disponible
          if ($env:CREDENTIAL_ID) {
            $arguments += "-credential_id"
            $arguments += "$env:CREDENTIAL_ID"
          }
          
          # Ejecutar firma
          & java $arguments
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "‚ùå Error al firmar MSI"
            exit 1
          }
          
          Write-Host "‚úÖ MSI firmado exitosamente"

      - name: üîê Sign EXE file with CodeSignTool
        if: env.EXE_FILE != ''
        shell: pwsh
        env:
          ES_USERNAME: ${{ secrets.SSLCOM_USERNAME }}
          ES_PASSWORD: ${{ secrets.SSLCOM_PASSWORD }}
          CREDENTIAL_ID: ${{ secrets.SSLCOM_CREDENTIAL_ID }}
          ES_TOTP_SECRET: ${{ secrets.SSLCOM_TOTP_SECRET }}
        run: |
          Write-Host "üîê Firmando EXE: $env:EXE_FILE"
          
          # Comando para firmar
          $arguments = @(
            "-jar", "$env:CODESIGNTOOL_JAR",
            "sign",
            "-username", "$env:ES_USERNAME",
            "-password", "$env:ES_PASSWORD",
            "-totp_secret", "$env:ES_TOTP_SECRET",
            "-input_file_path", "$env:EXE_FILE",
            "-output_dir_path", "$env:GITHUB_WORKSPACE\signed"
          )
          
          # Agregar credential_id si est√° disponible
          if ($env:CREDENTIAL_ID) {
            $arguments += "-credential_id"
            $arguments += "$env:CREDENTIAL_ID"
          }
          
          # Ejecutar firma
          & java $arguments
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "‚ùå Error al firmar EXE"
            exit 1
          }
          
          Write-Host "‚úÖ EXE firmado exitosamente"

      - name: ‚úÖ Verify signatures
        shell: pwsh
        run: |
          $signedFiles = Get-ChildItem -Path "$env:GITHUB_WORKSPACE\signed" -Include "*.exe", "*.msi" -Recurse
          
          if ($signedFiles.Count -eq 0) {
            Write-Warning "‚ö†Ô∏è No se encontraron archivos firmados"
            # Verificar si los archivos se sobrescribieron en lugar de guardarse en /signed
            Write-Host "Verificando archivos originales..."
            
            $originalFiles = @()
            if ($env:MSI_FILE) { $originalFiles += Get-Item $env:MSI_FILE }
            if ($env:EXE_FILE) { $originalFiles += Get-Item $env:EXE_FILE }
            
            $signedFiles = $originalFiles
          }
          
          Write-Host "üîç Verificando firmas de archivos..."
          foreach ($file in $signedFiles) {
            Write-Host "`nüìÑ Verificando: $($file.Name)"
            
            # Obtener informaci√≥n del certificado
            $cert = Get-AuthenticodeSignature -FilePath $file.FullName
            
            if ($cert.Status -eq "Valid") {
              Write-Host "‚úÖ Firma v√°lida"
              Write-Host "   Firmado por: $($cert.SignerCertificate.Subject)"
              if ($cert.TimeStamperCertificate) {
                Write-Host "   Timestamp: $($cert.TimeStamperCertificate.Subject)"
              }
            } else {
              Write-Host "‚ùå Error en la firma: $($cert.Status)"
              Write-Host "   StatusMessage: $($cert.StatusMessage)"
              # No fallar aqu√≠, solo advertir
              Write-Warning "La verificaci√≥n de firma fall√≥ pero continuamos..."
            }
          }

      
      - name: üìÇ Move signed files to correct location
        shell: pwsh
        run: |
          # Si los archivos est√°n en /signed, moverlos de vuelta
          $signedFiles = Get-ChildItem -Path "$env:GITHUB_WORKSPACE\signed" -Include "*.exe", "*.msi" -Recurse -ErrorAction SilentlyContinue
          
          if ($signedFiles.Count -gt 0) {
            foreach ($file in $signedFiles) {
              if ($file.Extension -eq ".msi") {
                $destination = ".\src-tauri\target\release\bundle\msi\"
              } elseif ($file.Extension -eq ".exe") {
                $destination = ".\src-tauri\target\release\bundle\nsis\"
              }
              
              Write-Host "üì• Moviendo archivo firmado: $($file.Name) a $destination"
              Move-Item -Path $file.FullName -Destination $destination -Force
            }
          } else {
            Write-Host "‚ÑπÔ∏è Los archivos fueron firmados in-place (sobrescritos)"
          }

      - name: üì§ Upload signed artifacts to release
        if: inputs.release_id != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: pwsh
        run: |
          # Buscar archivos firmados en sus ubicaciones finales
          $artifacts = @()
          $artifacts += Get-ChildItem -Path ".\src-tauri\target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue
          $artifacts += Get-ChildItem -Path ".\src-tauri\target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue
          
          foreach ($artifact in $artifacts) {
            if (Test-Path $artifact.FullName) {
              Write-Host "üì§ Subiendo a release: $($artifact.Name)"
              gh release upload ${{ inputs.release_id }} $artifact.FullName --clobber
            }
          }

      # ============= SUBIR COMO ARTIFACTS DEL WORKFLOW =============
      
      - name: üì§ Upload signed artifacts to workflow
        uses: actions/upload-artifact@v4
        with:
          name: signed-windows-binaries
          path: |
            src-tauri/target/release/bundle/msi/*.msi
            src-tauri/target/release/bundle/nsis/*.exe
          retention-days: 7

      # ============= EXTRAER SIGNATURES PARA OUTPUTS =============
      
      - name: üìù Extract signatures for outputs
        id: extract-signatures
        shell: pwsh
        run: |
          # Generar hash SHA256 del MSI firmado
          $msiFile = Get-ChildItem -Path ".\src-tauri\target\release\bundle\msi" -Filter "*.msi" | Select-Object -First 1
          
          if ($msiFile) {
            $hash = (Get-FileHash -Path $msiFile.FullName -Algorithm SHA256).Hash
            echo "windows_x86_64_sig=$hash" >> $env:GITHUB_OUTPUT
            echo "windows_x86_64_name=$($msiFile.Name)" >> $env:GITHUB_OUTPUT
            
            Write-Host "üìä Signature hash: $hash"
            Write-Host "üì¶ Package name: $($msiFile.Name)"
          }

      # ============= LIMPIAR ARCHIVOS TEMPORALES =============
      
      - name: üßπ Cleanup temporary files
        if: always()
        shell: pwsh
        run: |
          # Limpiar directorios temporales
          @("codesigntool", "signed") | ForEach-Object {
            if (Test-Path "$env:GITHUB_WORKSPACE\$_") {
              Remove-Item -Path "$env:GITHUB_WORKSPACE\$_" -Recurse -Force
              Write-Host "üóëÔ∏è Limpiado: $_"
            }
          }
          
          # Limpiar archivo ZIP
          if (Test-Path "CodeSignTool.zip") {
            Remove-Item "CodeSignTool.zip" -Force
          }

      # - name: üîê Sign Windows Executables with SSL.com
      #   run: |
      #     # Encontrar los archivos generados por Tauri
      #     $msiFiles = Get-ChildItem -Path ".\src-tauri\target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue
      #     $nsiFiles = Get-ChildItem -Path ".\src-tauri\target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue
      #     $exeFile = Get-Item ".\src-tauri\target\release\*.exe" -ErrorAction SilentlyContinue | Where-Object { $_.Name -like "*codefend*" }
          
      #     Write-Host "üì¶ Archivos encontrados para firmar:"
      #     if ($msiFiles) { Write-Host "  MSI: $($msiFiles.FullName)" }
      #     if ($nsiFiles) { Write-Host "  NSIS: $($nsiFiles.FullName)" }
      #     if ($exeFile) { Write-Host "  EXE: $($exeFile.FullName)" }
          
      #     # Funci√≥n para firmar con eSigner
      #     function Sign-WithESigner {
      #       param($FilePath)
            
      #       java -jar .\codesigntool\CodeSignTool.jar sign `
      #         -credential_id="${{ secrets.SSLCOM_CREDENTIAL_ID }}" `
      #         -username="${{ secrets.SSLCOM_USERNAME }}" `
      #         -password="${{ secrets.SSLCOM_PASSWORD }}" `
      #         -totp_secret="${{ secrets.SSLCOM_TOTP_SECRET }}" `
      #         -input_file_path="$FilePath" `
      #         -override=true
      #     }
          
      #     # Funci√≥n para firmar con SignTool
      #     function Sign-WithSignTool {
      #       param($FilePath)
            
      #       $signtool = "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\signtool.exe"
            
      #       # Si tienes un PFX
      #       if (Test-Path ".\certs\codefend.pfx") {
      #         & $signtool sign /f ".\certs\codefend.pfx" `
      #           /p "${{ secrets.SSLCOM_PASSWORD }}" `
      #           /tr "http://ts.ssl.com" `
      #           /td sha256 `
      #           /fd sha256 `
      #           /v "$FilePath"
      #       }
      #       # Si tienes certificado en el store de Windows
      #       else {
      #         & $signtool sign /n "Codefend, LLC" `
      #           /tr "http://ts.ssl.com" `
      #           /td sha256 `
      #           /fd sha256 `
      #           /v "$FilePath"
      #       }
      #     }
          
      #     # Decidir qu√© m√©todo usar
      #     $useESigner = "${{ secrets.SSLCOM_USE_ESIGNER }}" -eq "true"
          
      #     # Firmar cada archivo
      #     foreach ($file in @($msiFiles, $nsiFiles, $exeFile)) {
      #       if ($file -and (Test-Path $file.FullName)) {
      #         Write-Host "‚úçÔ∏è Firmando: $($file.Name)"
              
      #         if ($useESigner) {
      #           Sign-WithESigner -FilePath $file.FullName
      #         } else {
      #           Sign-WithSignTool -FilePath $file.FullName
      #         }
              
      #         # Verificar firma
      #         $signtool = "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\signtool.exe"
      #         & $signtool verify /pa /v $file.FullName
      #       }
      #     }